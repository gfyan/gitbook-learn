---
description: 这是redis中间件相关知识笔记
---

# redis部分

### 说说redis，它是什么？可以用来做什么？
redis是一个缓存中间件，是一个key-value类型的内存数据库，整个数据都是存在内存中的，所以redis读写性能相对较高，单机qps最高可高达10万次，在内存中的数据会定期通过异步操作把数据库数据flush到硬盘上进行保存。

### redis可以用于什么场景，都用了哪些功能？
redis可以用于一下场景：
- 用于储存热点数据，以加快热点数据的访问速度（string）。
- 用于记录用户报名计数，某个职位的点击数以及职位的评论数，并针对这些评论数以及点击数进行排序（zset）。
- 储存用户基础数据，比如头像、昵称、标签等简要信息（hash）。
- 做计数器，比如某个用户一天的报名量，一周的报名量等。
- 做分布式锁，用于多个微服务之间进行某个临界业务的访问。

### redis有什么优缺点？
- 优点1：速度快，redis是一个内存缓存中间件，所以他最大的优点是访问速度快，单机最大的qps可达10w。
- 优点2：支持丰富的数据类型，redis目前支持非常多的数据类型，比如String、List、Hash、Set、SortedSet，redis5.0还增加了Stream。
- 优点3：持久化机制，虽然redis的数据是储存在内存中的，但是redis有持久化机制将内存中的数据通过特定的策略将数据存放到硬盘上，使得redis即便是宕机，重启也能找回宕机之前的数据。
- 优点4：支持高可用，可通过redis Sentinel实现主从故障自动转移。通过Redis Cluster实现分片处理，可实现多master同时支持业务。

- 缺点1：内存敏感，依赖于机器的内存，稍有处理不当可能导致服务不可用。（ps：可通过cluster、Codis实现多master分区，达到高可用）。
- 缺点2：持久化机制在某些情况下可能导致备份过度占用cpu导致业务受到影响，且主从备份占用宽带也会有隐患存在。

### Redis和Memcached有什么区别？
1. redis支持复杂的数据结构，memcached只支持简单的字符串。
2. redis支持原生的集群模式，memcached不支持。
3. redis只能使用单核，但是memcached可以使用多核，在小数据上redis性能较高，但是在100k以上的数据memcached的性能更优。
4. redis支持持久化，memcached并不支持。
5. 内存管理机制，redis是使用时申请内存，memcached采用的是内存预分配策略。
6. redis的线程模型采用的是单线程IO多路复用模型，所以速度上来说是相当不错的。

### redis的数据结构有哪些，你都用过哪些数据，具体原理都了解吗？
redis支持很多类型的数据结构，常见的有string、hash、set、list、sortedSet，HyperLogLog、Geo、Bitmap，BloomFilter、RedisSearch、Redis-ML、JSON，redis5.0添加了Stream（流）的数据结构。

1. string（字符串），redis的字符串并非使用的是c语言底层的字符串，而是自己单独写了一个sds结构的动态字符串，该动态字符串类似于java里面的ArrayList，具有预分配内存、扩容、获取字符串长度为O(1)复杂度，sds内部结构封装了四个变量，总共分配的数组容量、已使用的数组容量、特殊标志位（占用1bytes，低）、数组内容。redis的字符串储存形式分为两种一种紧凑型一种非紧凑型，紧凑型是redisObject和sds连续分配内存，非紧凑RedisObject和sds是分开分配的，需要两次内存分配。
扩容机制：1M以内redis字符串扩容机制是100%扩容，超过1M扩容机制是每次多分配1M内存。<br>
max：最大长度不允许超过512M。<br>
embstr和raw形式：redis字符串超过44bytes会按照raw形式储存，44bytes以内都会以embstr储存，redisObject和sds一起分配内存。<br>
注意点：对字符串进行append也会变为raw形式储存，因为redis并未对embstr编码的字符串对象编写任何修改程序，换一句话说embstr是只读的，只有int和raw编码的对象字符串才可以修改。<br>

2. hash（哈希表），hash表示内存采用的是字典结构，字典是redis最常见且用途最广的数据结构，redis字典内部包含两个hashtable，通常情况下只有一个哈希表有值，另外一个在扩容的时候会存在值，字典除了hash会用以外，Zset也会用到，zSet里面的value-score的映射关系就是字典结构实现的。set用的也是字典结构，只不过set所有的value都是null<br>
扩容机制：一般当hash表中的所有元素个数等于一位数组的长度时会进行扩容，但是如果redis再进行bgsave的话，为了减少内存页的分离会尽量不扩容，但是如果hash表变的非常臃肿，元素个数已经达到了一维数组的5倍时，会进行强制扩容。<br>
扩容大小：新数组是原数组大小的2倍。<br>
缩容机制：当hash表中的所有元素低于一维数组长度的10%，redis会考虑对该hash表进行缩容。<br>

3. list（列表），类似于java中的LinkedList，但是redis的列表有所不同，最早期采用的也是双向链表来实现，但是双向链表会产生内存较多的内存碎片问题，所以redis后面对列表进行了改进，改成了快速列表（quicklist），quicklist是ziplist（压缩列表）+linkedlist（双向列表）结合体，它将linkedlist按段进行压缩，每一段用ziplist紧凑储存，多个ziplist使用双向指针串联起来。默认单个ziplist储存大小为8k，超过便会新起一个ziplist，ziplist储存大小由list-max-ziplist-size控制。


4. set（无序集合、不可重复），set集合采用的hashtable结构，只不过value为null，当数据较少的时候set采用的是intset结构。

5. zset（有序集合），zset有序集合，底层采用的是跳跃表来实现，不过zset在元素介绍的时候会采用压缩列表储存，以达到节约内存的目的。<br>
为什么zset采用跳跃表而不使用AVL或者红黑树？原因有四点，1.跳跃表相比AVL和红黑树更适合做范围查找。2.平衡树和红黑树的插入以及删除可能引起子树的调整，操作较为复杂。3.从内存上来说跳跃表比平衡树更灵活一些，平衡树每个节点都会有包含指向左右节点的两个指针，但是跳跃表并不是，按照公式每个节点包含指针为1/(1-p)。

6. HyperLogLog是一个计数器，用来计算一个网站访问的uv数值，而且HyperLogLog并不耗费内存，HLL采用两种编码方式，稀疏编码和密集编码，稀疏编码只需要6bytes就存储了密集编码12kb储存的数据。HLL具体原理是采用了超对数计数算法，超对数计数算法类似于抛硬币，抛硬币的次数和最大连续抛出正面的次数成对数线性关系。HLL密集编码采用了2^14次方个桶分别进行储存最大连续1的个数，HyperLogLog每次添加元素都会对数据先进行hash得到64位，然后取低14位取到桶位置，然后对剩下50位进行连续1计算，然后储存对应的值。

7. Geo用于地图计算，可以计算两个地理位置，一般用于地图搜索。

8. Bitmap（位图），一般用于记录用户行为数据，例如登录痕迹或者签到痕迹等，可以节约很多内存。

9. BloomFilter（布隆过滤器），一般用于去重场景使用，可以判断某一个值是否存在，BloomFilter的实现原理是一个超大型的位数组和几个不一样的hash函数，每个元素通过BloomFilter添加的时候，都会使用多个hash函数对元素进行hash计算，多个hash函数得出来的hash值和位数组进行取模得到一个下标，然后将对应的下标置为1。BloomFilter的判断准确度取决于位数组的长度和hash函数个数。

注意点：BloomFilter判断一个元素不存在的时候，那么这个元素一定不存在，如果说一个元素存在的时候，这个元素有可能不存在。


### 怎么在线上坏境中找出符合特定规则的key列表？（ps：key在一千万左右）
数据量非常大的情况下使用scan去循环查找，数据量小可以选择keys 简单粗暴，数据量大的情况下不建议使用keys，数据量多的情况下会导致整个服务卡顿，从而导致应用服务出错。

scan的原理：因为redis中所有的key都是存放在一个大型字典中的，所以只要对一维数组进行挨个遍历就可以扫描所有的key，并且scan采用的是高位进位进行扫描的，可能会重现重复元素。采用高位进位扫描主要是避免遗漏。

### redis的线程模型了解吗？具体说说。
redis的线程模型是单线程IO多路复用，为什么说redis是单线程IO多路复用呢，因为redis是基于Reactor模式开发了网络事件处理器，这个事件处理器被称为文件事件处理器，它的组成包含四个部分：套接字、IO多路复用程序、文件事件分派器、事件处理器，文件事件处理器是以单线程方式运行的，虽然是单线程但是利用了I/O多路复用来监听套接字，所以文件事件处理器也能展现相当高的性能。

### redis的持久化策略有哪几种，都各有什么优缺点。
redis的持久化策略有两种方式，一种是RDB方式一种是AOF，redis4.0后出现了RDB和AOF混合模式。

- RDB策略

RDB持久化策略是采用快照原理，redis本身会fork一个子进程进行RDB快照持久化，RDB是全量备份，会扫描内存中所有的数据，然后对数据进行序列化，然后写入到硬盘上，因为进行持久化的时候主线程还会接受客户端请求，所以redis采用的是COW机制来进行客户端的请求处理，redis的数据都是按照页存在内存中的，客户端每来一个修改请求主线程都会拷贝一份数据出来进行修改，子线程全程是无感知的，而且扫描过程中数据不会变。

默认策略有三个，1. 60秒内，对数据库进行了至少10000次修改则进行bgsave，2. 5分钟内，对数据库进行了至少10次修改，3. 15分钟内，对数据库进行了至少1次修改。

**优点：**
1. 恢复快，相较于AOF机制，RDB在redis宕机后重启速度更快一些，尤其数据里大的情况提现最为明显。
2. 相较于AOF占的磁盘空间要少一些。

**缺点：**
1. 容易丢失数据，RDB不能设置备份频率过高，这样是使得IO压力增加，但也不能设置过长容易丢失数据。
2. 数据量非常大的情况会导致IO频率较高，而且如果在备份的时候请求频率过快会耗费过多的内存，最终导致swap从而使得redis性能下降。


- AOF策略

AOF持久化策略则是使用增量原理，AOF备份的是redis指令序列，AOF日志只记录对redis数据进行修改的指令，所以随着时间的推移AOF日志会越来越大，所以AOF会定时对AOF日志文件进行瘦身，原理就是扫描一遍内存数据然后转换为对应的指令存入AOF日志文件中，因为进行瘦身的时候redis还需要继续服务，这个期间所有的操作都会被放在AOF缓冲区和AOF重写缓冲区，多了一个AOF重写缓冲区，当AOF瘦身完毕的时候会释放一个信号给父进程，父进程接受信号之后会调用信号处理函数将AOF缓冲区的内存写到新的AOF文件中，然后将新的AOF文件原子替换为老的AOF文件。

默认策略有三种，1.每个命令结束后都会将命令写入AOF缓冲区且写入到AOF文件中，并且同步AOF文件。2.每个命令结束后都会将命令写入AOF缓冲区且写入到AOF文件中，并且每秒同步AOF文件。3.每个命令结束后都会将命令写入AOF缓冲区且写入到AOF文件中，不同步AOF文件也就是不刷新系统的写缓冲，完全依赖于系统。

**优点：**
1. 会有更高的数据安全性，相对于RDB持久化来说AOF持久化更能保障数据的备份。
2. AOF持久化采用的是append模式，即便是在持久化的同时宕机也不影响之前已经备份的数据。

**缺点：**
1. AOF日志会随着时间推移越来越大，而且即便是瘦身之后通常情况下也要比RDB文件大，因为AOF日志文件存的是指令。
2. AOF重放恢复数据较慢，相较于RDB数据恢复要慢很多。

- RDB、AOF混合策略

既然RDB和AOF都各自有优缺点，那么能不能出一套完整的持久化呢，那就是RDB、AOF混合模式，因为AOF进行重写的时候本身就会扫描内存所有的数据然后转换为指令存在AOF日志文件中，那么AOF重写的时候直接采用RDB模式进行持久化即可，然后AOF增量日志在后面进行追加即可，后续进行数据恢复的时候只需要分段加载即可，前半段采用RDB进行数据恢复，后半段进行AOF进行数据恢复。

